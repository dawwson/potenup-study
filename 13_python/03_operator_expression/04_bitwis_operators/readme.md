## 📚 Chapter 03. 연산자와 표현식 - 섹션 3.4 비트 연산자

### 🎬 도입 스토리

뉴런테크의 'IoT 하드웨어 최적화 팀'에 긴급 호출이 떨어졌습니다. 우리가 만든 초소형 센서 기기는 메모리가 매우 부족해서, 데이터 하나를 저장할 때도 바이트(Byte) 단위가 아니라 비트(Bit) 단위로 아껴 써야 합니다.

팀장이 당신에게 말합니다. "신입 사원님, 사용자 권한 정보 8개를 저장해야 하는데, 이걸 각각 `bool` 변수 8개로 만들면 최소 8바이트(또는 그 이상)를 소모합니다. 하지만 비트 연산을 사용하면 단 1바이트(8비트) 안에 모든 정보를 때려 넣을 수 있죠. 전송 속도도 8배 빨라집니다. 자, 이제 '숫자'라는 껍데기를 벗겨내고 그 안에 숨겨진 0과 1의 세계를 직접 제어해 봅시다."

당신은 처음엔 당황스럽겠지만, 곧 깨닫게 될 것입니다. 우리가 다루는 모든 고수준 언어의 밑바닥에는 결국 이 비트 연산이 흐르고 있으며, 이를 자유자재로 다루는 것이야말로 진정한 '시스템 레벨' 개발자로 가는 관문이라는 것을요.

---

### 비트(Bit)와 비트 연산자

컴퓨터는 모든 데이터를 0과 1로 처리합니다. 비트 연산자는 정수를 이진수(Binary)로 펼쳐놓고, 각 자리수끼리 연산을 수행합니다.

| 연산자 | 이름          | 설명                                                       |
| ------ | ------------- | ---------------------------------------------------------- | ------------------------------------------- |
| `&`    | AND           | 대응하는 두 비트가 모두 1일 때만 1을 반환                  |
| `      | `             | OR                                                         | 대응하는 두 비트 중 하나라도 1이면 1을 반환 |
| `^`    | XOR           | 대응하는 두 비트가 서로 다를 때만 1을 반환 (배타적 논리합) |
| `~`    | NOT           | 비트를 반전 (0은 1로, 1은 0으로)                           |
| `<<`   | 왼쪽 시프트   | 비트를 왼쪽으로 이동 (빈자리는 0으로 채움)                 |
| `>>`   | 오른쪽 시프트 | 비트를 오른쪽으로 이동                                     |

### 내부 동작 원리

**1. 이진수 표현과 메모리 (2의 보수)** <br>
파이썬의 정수는 내부적으로 2의 보수(2's Complement) 방식을 사용하여 양수와 음수를 표현합니다.

- 예를 들어 정수 `5`는 이진수로 `...00000101`입니다.
- `~5`를 수행하면 모든 비트가 반전되어 `-6`이 됩니다. > `1111 1010`(반전)
- (파이썬 정수는 무한 정밀도이므로, 가장 왼쪽의 부호 비트가 무한히 확장되는 개념을 가집니다.)

**2. 시프트 연산과 곱셈/나눗셈의 관계 (Fast Math)** <br>
비트를 왼쪽으로 한 칸 밀어내는(`<< 1`) 행위는 수학적으로 **2를 곱하는 것**과 완벽히 일치합니다. <br> 반대로 오른쪽으로 한 칸 밀어내는(`>> 1`) 행위는 **2로 나누는(몫)** 것과 같습니다.

- 예: `4 << 1`은 `8`이 되고, `9 >> 1`은 `4`가 됩니다.
  - `4`의 이진수 표현은 `0000 0100`이고 `<< 1`을 하면 `0000 1000`이 되어 `8`이 됩니다.
  - `9`의 이진수 표현은 `0000 1001`이고 `>> 1`을 하면 `0000 0100`이 되어 `4`가 됩니다.

* **CPU 관점**: ALU(산술 논리 장치)에서 일반적인 곱셈(`*`)이나 나눗셈(`/`) 연산보다 시프트 연산이 훨씬 적은 `클럭 사이클을 소모`합니다. 고성능 그래픽 엔진이나 암호화 알고리즘에서 `시프트 연산을 애용`하는 이유입니다.

**3. 비트 마스킹 (Bit Masking)** <br>
특정 비트의 값만 추출하거나(AND), 특정 비트만 1로 만들거나(OR), 특정 비트만 뒤집고(XOR) 싶을 때 '마스크(Mask)'를 사용합니다.

- 예 : 정수 4는 2진수로 `0000 0100`입니다. <br>
  - `4 & 1`은 `0000 0100 & 0000 0001`이 되어 `0000 0000` 즉, `0`이 됩니다.
    (최하위 비트 추출)
    - & : 두 비트가 모두 1일 때만 1이 됨
  - `4 | 1`은 `0000 0100 | 0000 0001`이 되어 `0000 0101` 즉, `5`가 됩니다. (최하위 비트 설정)
    - | : 두 비트 중 하나라도 1이면 1이 됨
  - `4 ^ 1`은 `0000 0100 ^ 0000 0001`이 되어 `0000 0101` 즉, `5`가 됩니다. (최하위 비트 토글)
    - ^ : 두 비트가 다를 때만 1이 됨

### 주의사항 및 베스트 프랙티스

- **가독성**:
  <br>비트 연산은 코드가 매우 추상적으로 보일 수 있습니다.
  <br> 반드시 주석을 달거나, 2진수 리터럴(`0b...`)을 사용하여 어떤 비트를 건드리는지 명시해야 합니다.
- **우선순위**: <br>
  비트 연산자는 비교 연산자(`==`, `!=`)보다 우선순위가 낮을 수 있습니다.<br> 의도치 않은 결과를 막기 위해 **괄호 `()`** 를 적극적으로 사용하세요. (예: `(a & mask) == mask`)

- **파이썬의 정수 특성**: <br>
  파이썬은 정수 크기에 제한이 없어 다른 언어(C/C++)의 32비트 연산과는 조금 다르게 동작할 수 있습니다(특히 `~` 연산). 시스템 프로그래밍 시 이 점을 유의해야 합니다.

### 🎓 핵심 요약

1. **비트 연산자의 정체**: 데이터를 최소 단위인 비트(0, 1) 수준에서 직접 조작하는 도구입니다.
2. **효율적인 상태 관리**: 비트 플래그와 마스킹(`&`, `|`)을 통해 수많은 상태 정보를 하나의 정수 안에 압축하여 저장하고 빠르게 검사할 수 있습니다.
3. **성능 최적화**: 시프트 연산(`<<`, `>>`)은 CPU 레벨에서 매우 빠른 곱셈과 나눗셈 수단으로 활용됩니다.
4. **XOR의 마법**: 암호화나 데이터 복구, 상태 토글에 유용하게 쓰이는 XOR(`^`)의 특성을 이해했습니다.
