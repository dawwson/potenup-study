## 📚 Chapter 03. 연산자와 표현식 - 섹션 3.3 할당 연산자와 복합 할당

### 🎬 도입 스토리 (300~500자)

뉴런테크의 게임 개발 본부로 파견된 당신에게 선배 개발자가 한 가지 코드를 보여줍니다. "자, 여기 주인공 캐릭터가 경험치를 얻는 로직이 있어요. `current_exp = current_exp + 100`이라고 되어 있죠? 틀린 코드는 아니지만, 실무에서 수백 개의 능력치를 이렇게 관리하면 코드가 너무 길어지고 가독성이 떨어집니다."

당신은 생각합니다. '어차피 결과는 같은데, 더 짧게 쓰는 게 그렇게 중요한가?'

시니어 개발자는 여러분의 고민을 꿰뚫어 본 듯 설명합니다. "단순히 짧게 쓰는 것이 목표가 아닙니다. <br> `+=`와 같은 **복합 할당 연산자**를 사용하면, 코드를 읽는 사람에게 '이 변수의 현재 상태를 기반으로 값을 업데이트한다'는 의도를 더 명확하게 전달할 수 있습니다. 또한, 파이썬 인터프리터 수준에서 연산을 조금 더 효율적으로 처리할 수 있는 여지를 주기도 하죠. 오늘은 변수에 값을 저장하는 '할당'의 깊은 원리와, 이를 더 세련되게 처리하는 '복합 할당'의 세계를 탐험해 보겠습니다."

---

### 기본 개념: 할당 연산자 (=)

프로그래밍에서 `=` 기호는 수학에서의 '같다'가 아니라 **'오른쪽의 결과를 왼쪽의 변수에 집어넣는다'** 는 의미입니다. 이를 **할당(Assignment)** 이라고 부릅니다.

- **L-value (좌항)**:
  - 값이 저장될 메모리 공간의 이름(변수)입니다.
  - 반드시 변수여야 합니다.
- **R-value (우항)**:
  - 저장될 실제 값이나 계산식입니다.
  - 리터럴(값), 다른 변수, 혹은 복잡한 연산식이 올 수 있습니다.

### 복합 할당 연산자 (Augmented Assignment Operators)

산술 연산과 할당을 한 번에 처리하는 연산자입니다. 코드를 간결하게 만들고 업데이트 의도를 명확히 합니다.

- `+=`: 더한 후 할당 (`a += b` ➔ `a = a + b`)
- `-=`: 뺀 후 할당 (`a -= b` ➔ `a = a - b`)
- `*=`: 곱한 후 할당 (`a *= b` ➔ `a = a * b`)
- `/=`: 나눈 후 할당 (`a /= b` ➔ `a = a / b`)
- `//=`: 몫을 구한 후 할당 (`a //= b` ➔ `a = a // b`)
- `%=`: 나머지를 구한 후 할당 (`a %= b` ➔ `a = a % b`)
- `**=`: 거듭제곱 후 할당 (`a **= b` ➔ `a = a ** b`)

### 깊이 있는 이해: 내부 동작 원리

**1. 메모리 재할당의 재확인 (Immutable Object)** <br>
우리는 앞서 파이썬의 숫자(`int`, `float`)가 **불변(Immutable)** 객체임을 배웠습니다.<br>
`score += 10`이라는 코드가 실행될 때, 메모리 내부에서는 다음과 같은 일이 벌어집니다.

1. `score`가 가리키는 현재 정수 객체의 값을 읽어옵니다.
2. 여기에 `10`을 더한 **새로운 정수 객체**를 메모리에 생성합니다.
3. `score`라는 변수 이름(포인터)이 기존 객체를 버리고 새 객체의 주소를 가리키도록 업데이트합니다.<br>
   즉, 복합 할당 연산자를 써도 내부적으로 '새 객체 생성 + 참조 변경'의 과정은 동일하게 일어납니다.

**2. 인터프리터와 바이트코드 (Bytecode)** <br>
파이썬 인터프리터는 `a = a + 1`을 볼 때보다 `a += 1`을 볼 때 조금 더 최적화된 명령어를 사용합니다.

> a = a + 1 (Standard Assignment)
>
> - 이 방식은 전형적인 **"우항을 계산해서 좌항에 대입한다"** 는 로직입니다.
> - 바이트코드 흐름:
>   - LOAD_NAME (a): `스택에 변수 a의 값을 올립`니다.
>   - LOAD_CONST (1): `스택에 상수 1을 올립`니다.
>   - BINARY_ADD: 스택의 두 값을 꺼내 더한 뒤, `새로운 객체를 만들어 스택에 올립`니다. <br>(내부적으로 a.**add**(1) 호출)
>   - STORE_NAME (a): 스택에 있는 결과물(새 객체)의 주소를 변수 a에 저장합니다.
>     > [!NOTE] 핵심: 무조건 새로운 결과물을 만들겠다는 의도가 강합니다.

> a += 1 (Augmented Assignment)
>
> - 이 방식은 **"가능하다면 현재 객체를 직접 수정(In-place)하고, 안 되면 새로 만들어라"** 는 최적화된 로직입니다.
> - 바이트코드 흐름:
> - LOAD_NAME (a): 스택에 a를 올립니다.
> - LOAD_CONST (1): 스택에 1을 올립니다.
> - INPLACE_ADD:
>   - 이 명령어가 실행되면 PVM은 객체 a가 ****iadd** (In-place Add)** 를 지원하는지 확인합니다.
>   - Mutable (리스트 등): 기존 객체 내부를 직접 수정하고 자기 자신의 주소를 다시 반환합니다.
>   - Immutable (정수, 문자열 등): 수정이 불가능하므로 내부적으로 BINARY_ADD와 똑같이 작동하여 새 객체를 만듭니다.
> - STORE_NAME (a): 반환된 주소를 다시 a에 저장합니다.

**3. 평가 순서 (Evaluation Order)** <br>
복합 할당 연산자에서 우측(R-value)에 복잡한 식이 올 경우, **우측 식 전체가 먼저 계산**된 후 마지막에 할당이 일어납니다. <br>

- 예: `x *= a + b`는 `x = x * (a + b)`와 같습니다. `x = x * a + b`가 아님을 주의해야 합니다.

### 주의사항 및 베스트 프랙티스

- **초기화 필수**: 복합 할당 연산자는 기존 값을 참조하므로, 변수가 사전에 선언되어 있지 않으면 `NameError`가 발생합니다.
- **타입 변화 주의**: `a = 10` (int) 일 때 `a /= 2`를 수행하면 `a`는 `5.0` (float)이 됩니다. 연산자의 특성에 따라 변수의 타입이 바뀔 수 있음을 인지해야 합니다.
- **가독성 최우선**: 너무 복잡한 수식을 한 줄의 복합 할당으로 처리하려다 보면 오히려 가독성을 해칠 수 있습니다. "이 변수의 상태를 업데이트한다"는 의미가 살아날 때 사용하세요.

### 🎓 핵심 요약

이번 섹션에서 우리는 다음 내용을 배웠습니다:

1. **할당의 본질**: `=` 연산자는 우항의 값을 좌항의 변수가 가리키는 메모리 공간에 연결(바인딩)하는 작업입니다.
2. **복합 할당의 편리함**: `+=`, `-=`, `*=` 등은 코드를 간결하게 만들 뿐 아니라, 변수의 상태를 업데이트한다는 의도를 명확히 전달합니다.
3. **내부 동작과 불변성**: 숫자형 변수에 복합 할당을 수행할 때도 파이썬은 내부적으로 새로운 객체를 생성하며, 이는 `id()` 함수로 증명할 수 있습니다.
4. **연산 순서와 타입**: 우변이 먼저 평가된다는 점과, `/=` 연산 시 결과가 항상 실수형으로 변한다는 점을 주의해야 합니다.
