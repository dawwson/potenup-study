# 코스: 헥사고날 아키텍처 완벽 가이드

## 모듈 1: 아키텍처의 진정한 목적 (심층)

> ### 학습 목표
> 소프트웨어 아키텍처의 근본적인 목적을 이해하고, 전통적인 방식의 한계를 명확히 인지한다. 헥사고날 아키텍처가 '왜' 패러다임의 전환을 가져왔는지 그 철학적 배경과 핵심 원리(내/외부, 포트, 어댑터, 의존성 규칙)를 완벽히 파악한다.

---

## 🏛️ 아키텍처의 목적과 '관심사의 분리'

> "좋은 아키텍처는 무엇인가?"

이 질문에 답하기 전에, '아키텍처'가 왜 필요한지부터 알아야 한다. 소프트웨어는 '변경'을 먹고 자란다. <br>
오늘 만든 시스템은 내일 당장 "결제 방식을 PG사에서 엑심베이로 변경해 주세요", "데이터베이스를 Oracle에서 PostgreSQL로 이전해 주세요"와 같은 변경 요구사항에 직면한다.

좋은 아키텍처란, 이러한 '변경'에 유연하게 대응할 수 있는 구조를 설계하는 것이다.

이를 위한 가장 고전적이고 강력한 원칙이 **'관심사의 분리(Separation of Concerns, SoC)'**이다.

시스템은 서로 다른 '관심사'를 가진 코드의 묶음이다.

* **핵심 비즈니스 로직 (도메인):** 시스템의 존재 이유. (예: "주문 총액을 계산한다", "재고가 있는지 확인한다")
* **애플리케이션 로직 (유스케이스):** 비즈니스 로직을 조율하는 흐름. (예: "주문 요청을 받아, 재고를 확인하고, 주문을 생성한 후, 결제를 요청한다")
* **인프라 (기술):** 위 로직을 '어떻게' 수행할지 돕는 기술. (예: Spring Web으로 요청을 받고, JPA로 DB에 저장하며, Kafka로 이벤트를 보낸다)

이 셋은 '변경의 주기'가 다르다. '주문 총액 계산' 로직은 10년이 지나도 잘 변하지 않지만, 'DB 저장' 기술은 3년마다 바뀔 수 있다.

> **[핵심]**
> 좋은 아키텍처는 '변경 주기가 다른' 코드, 특히 **'비즈니스 로직(도메인)'**과 **'인프라(기술)'**를 서로 완벽하게 분리하여, 한쪽의 변경이 다른 쪽에 영향을 미치지 않도록 격리하는 것이다.

---

## 📉 전통적 계층형 아키텍처의 딜레마

전통적인 N계층 아키텍처(N-Layered Architecture) (예: Presentation - Business - Data)는 '관심사의 분리'를 시도한 첫 번째 모델이다.



[Image of N-Layered Architecture diagram]


이 구조의 규칙은 간단하다. "상위 계층은 하위 계층에만 의존한다."

* `Presentation (Controller)` -> `Business (Service)`
* `Business (Service)` -> `Data (Repository)`

이 구조는 단순해 보이지만, 치명적인 딜레마에 빠진다.

* **DB가 시스템을 지배한다:** Service가 Repository를 의존한다. 즉, 비즈니스 로직이 데이터베이스 기술에 의존한다. 만약 Data 계층이 JPA로 구현되었다면, Service 계층의 Order 객체는 JPA의 `@Entity` 어노테이션을 갖게 될 가능성이 높다. 이는 순수해야 할 비즈니스 로직이 DB 기술에 '오염'되었음을 의미한다.
* **의존성의 방향이 잘못되었다:** '관심사의 분리' 원칙에 따르면, 중요한 '비즈니스 로직'은 덜 중요한 '인프라(DB)'에 의존해서는 안 된다. 하지만 계층형 아키텍처는 정확히 그 반대로 동작한다.
* **테스트가 어렵다:** Service를 테스트하려면 Repository를 Mocking해야 한다. 비즈니스 로직을 테스트하는데, DB 관련 코드가 발목을 잡는다.

---

##  hexagonal 패러다임의 전환: 헥사고날 아키텍처

Alistair Cockburn은 이 딜레마를 해결하기 위해 2005년 'Ports and Adapters' 아키텍처를 제안했다. 이것이 '헥사고날(육각형) 아키텍처'로 더 잘 알려져 있다.



### 왜 '헥사고날'인가?

육각형(Hexagon)은 시각적인 은유(Metaphor)일 뿐이다.

* 전통적인 상하(Top-Down) 구조가 아니라, 시스템의 **'안(Inside)'**과 **'밖(Outside)'**이라는 중심(Center) 구조를 강조하기 위함이다.
* '육각형'의 여러 '면(Face)'은 시스템이 다양한 외부 요소(웹, DB, 메시지 큐...)와 연결될 수 있음을 상징한다.

### 핵심 철학: '내부'와 '외부'의 분리

헥사고날 아키텍처는 시스템을 두 영역으로 나눈다.

* **내부 (Inside / Application Core):**
    * 시스템의 심장. 순수한 비즈니스 로직(도메인)과 이를 조율하는 유스케이스(애플리케이션 로직)가 있는 곳.
    * **규칙:** 이 영역은 '외부'에 대해 아무것도 알지 못한다. `import` 문에 Spring, JPA, Web 관련 코드가 단 한 줄도 없어야 한다.
* **외부 (Outside / Infrastructure):**
    * '내부'를 둘러싼 모든 기술. (예: `Spring Controller`, `JpaRepository`, `KafkaProducer`)
    * '외부'는 '내부'를 알고 의존해야 하지만, 그 반대는 절대 성립하지 않는다.

---

## 🔌 연결의 계약: 포트 (Ports)

'내부'가 '외부'를 모르는데, 둘은 어떻게 통신할까? '내부' 영역의 경계에 **'포트(Port)'**를 정의한다.

### 포트(Port)란 무엇인가?

> '내부' 영역이 외부 세계와 상호작용하기 위한 **'관문(Gateway)'**이다.
> '내부' 영역에 정의된 **'기술 중립적인 인터페이스(Interface)'**이다.

이 인터페이스는 '외부'가 아닌 '내부'의 비즈니스 용어로 작성된다.

* (나쁜 예) `saveOrderToDatabase(OrderData data)`
* (좋은 예) `save(Order order)`

> **[핵심]**
> 포트는 '내부'의 Application Core에 속한다. '외부'에 무엇이 있는지 상관없이 '내부'가 "나는 이런 기능이 필요해" 또는 "나는 이런 기능을 제공해"라고 선언하는 **명세(Specification)이자 계약(Contract)**이다.

## ⚙️ 실제 구현: 어댑터 (Adapters)

'내부'가 정의한 '포트(인터페이스)'를 실제로 구현하는 것은 '외부'의 **'어댑터(Adapter)'**이다.

### 어댑터(Adapter)란 무엇인가?

> '외부' 영역에 존재하며, 특정 기술을 사용하여 '포트'의 명세를 실제로 구현하는 클래스다.
> 어댑터는 '외부'의 기술(예: JPA)과 '내부'의 포트(인터페이스) 사이의 '번역가' 또는 '변환기' 역할을 한다.

### 비유: USB 포트와 어댑터

* **노트북의 USB-C 포트 (Port):** 노트북('내부')에 정의된 표준 명세. "나는 이 규격으로 전원과 데이터를 받을 수 있어."
* **HDMI 어댑터 (Adapter):** 모니터('외부' 기술)를 노트북의 USB-C 포트('내부' 포트)에 연결해주는 '번역가'.
* **전원 어댑터 (Adapter):** 220V 전원('외부' 기술)을 노트북의 USB-C 포트('내부' 포트)에 연결해주는 '번역가'.

노트북(내부)은 'HDMI'나 '220V'의 존재를 모르지만, 'USB-C 포트'라는 명세를 통해 이들과 통신할 수 있다.

---

## 🔄 [심화] 주도권의 역전: Driving vs. Driven

포트와 어댑터는 "누가 대화를 시작하는가?"(주도권)에 따라 두 가지 유형으로 나뉜다. 이는 매우 중요한 개념이다.



### 1. 프라이머리 어댑터 (Primary / Driving Adapters)

* **역할:** '내부'의 비즈니스 로직을 **"호출하는(Driving)"** 주체.
* **방향:** 외부 -> 내부 (Inbound)
* **예시:**
    1.  사용자가 웹사이트에서 버튼을 클릭 (외부 행위)
    2.  `Web Controller` (프라이머리 어댑터)가
    3.  `CreateOrderUseCase` (인바운드 포트)를 호출한다.
* *(예: WebController, GraphQL Resolver, CLI Command, Batch Job Trigger)*

### 2. 세컨더리 어댑터 (Secondary / Driven Adapters)

* **역할:** '내부'의 비즈니스 로직에 의해 **"호출되는(Driven)"** 주체.
* **방향:** 내부 -> 외부 (Outbound)
* **예시:**
    1.  `CreateOrderService` (내부 로직)가 "주문 저장"을 결정
    2.  `OrderRepository` (아웃바운드 포트)를 호출
    3.  `JpaOrderAdapter` (세컨더리 어댑터)가 이 호출을 받아 실제 DB에 저장한다.
* *(예: JpaPersistenceAdapter, KafkaEventPublisher, S3FileUploader, RestApiClient)*

---

## 💡 [핵심] 모든 것을 가능하게 하는 원리: DIP

이 모든 구조가 어떻게 가능할까? 바로 **의존성 역전 원칙(Dependency Inversion Principle, DIP)** 때문이다.



* **전통적 의존성:** `Business(내부)` -> `Data(외부)`
    * '내부'가 '외부'의 구체적인 구현을 의존했다.
* **헥사고날 의존성 (DIP 적용):**
    * `Business(내부)` -> `OrderRepository(내부 포트 인터페이스)`
    * `JpaAdapter(외부)` -> `OrderRepository(내부 포트 인터페이스)`

의존성의 방향이 '역전'되었다.
`JpaAdapter(외부)`가 `OrderRepository(내부)`를 **구현(implements)**함으로써, 의존성 화살표가 '외부'에서 '내부'를 향하게 된다.

> **[핵심 결론]**
> 헥사고날 아키텍처는 DIP를 통해 '관심사의 분리'라는 아키텍처의 근본 목적을 달성한다. 모든 의존성이 '내부'를 향하게 만듦으로써, '내부'의 순수한 비즈니스 로직을 '외부'의 불안정한 기술 변화로부터 완벽하게 **보호(격리)**한다.

---

## 🗺️ 설계의 시작: 유스케이스 식별 (README)

개발자들이 흔히 하는 실수는 '헥사고날 아키텍처'라는 이름에 집중해 패키지 구조부터 나누는 것이다. (예: `domain`, `adapter`, `port`)

중요한 것은 패키지 구조가 아니라 **'포트(인터페이스)'를 먼저 식별**하는 것이다.

코드를 작성하기 전에, `README.md` 파일이나 간단한 텍스트 문서에 다음을 먼저 정의해보는 것이 이 아키텍처의 핵심이다.

#### 이 시스템의 '인바운드 포트'는 무엇인가? (Use Cases / Driving)

* *외부에서 시스템에 무엇을 시키는가?*
* 주문 생성(`CreateOrderUseCase`)
* 주문 조회(`GetOrderUseCase`)

#### 이 시스템의 '아웃바운드 포트'는 무엇인가? (External Needs / Driven)

* *시스템이 외부에 무엇을 요구하는가?*
* 주문 저장소(`OrderRepository`)
* 결제 요청(`BillingApi`)
* 이벤트 발행(`OrderEventPublisher`)

> **설계도(README) 없이 집(패키지)부터 짓지 마라.**
> 이 인터페이스(설계도)들이 명확해지면, '내부'와 '외부'의 경계가 명확해지며, 비로소 견고한 구조를 만들 수 있다.